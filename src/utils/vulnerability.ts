import get from 'lodash.get';

import { isJsonString, trimArray } from './common';
import { color, getSeverityBgColor } from './color';
import { printExceptionReport } from './print';
import { analyzeExpiry } from './date';
import { readFile } from './file';

import {
  NpmAuditJson,
  v7VulnerabilityVia,
  ProcessedResult,
  ProcessedReport,
  v6Advisory,
  v7Vulnerability,
  NsprcConfigs,
  NsprcFile,
  AuditLevel,
  AuditNumber,
  ParsedCommandOptions,
  DependenciesTrustResult,
} from 'src/types';

const MAX_PATHS_SIZE = 5;

/**
 * Map out all the dependencies path for a module
 * @param   {String} path   Full dependency path for the reported module
 * @return  {Array}         Array of dependency paths
 */
export function mapModuleDependencies(path: string): string[] {
  return path.split('node_modules/').reduce((acc: string[], cur: string) => {
    // Ends with '/' meaning it is the dependency and not the final module (reported module)
    if (!cur.endsWith('/')) {
      return acc;
    }
    // Append with last dependencies path
    return acc.concat(`${acc[acc.length - 1] || ''}node_modules/${cur}`);
  }, []);
}

/**
 * Converts an audit level to a numeric value
 * @param  {String} auditLevel  Audit level
 * @return {Number}             Numeric level: the higher the number, the more severe it is
 */
export function mapLevelToNumber(auditLevel: AuditLevel | string): AuditNumber {
  switch (auditLevel) {
    case 'info':
      return 0;
    case 'low':
      return 1;
    case 'moderate':
      return 2;
    case 'high':
      return 3;
    case 'critical':
      return 4;
    default:
      return 0;
  }
}

/**
 * Check if it is fine to except the reported vulnerability by checking the inner dependencies
 * @param   {Number}  vulnerabilityId       Reported vulnerability ID
 * @param   {Array}   affectedModulePaths   Reported module path
 * @return  {Object}                        Return the details if it can be excepted
 */
export function checkTrustInDependencies(vulnerabilityId: number, affectedModulePaths: string[]): DependenciesTrustResult {
  const scannedPaths: string[] = [];
  const foundPaths: string[] = [];
  const report: string[][] = [];

  // Using `.reduce` instead of `.every` to provide better overview details in the report
  const trust = affectedModulePaths.reduce((finalTrust, affectedModule) => {
    // Get all the dependencies that is using this reported module
    const dependencyPaths = mapModuleDependencies(affectedModule);

    // Audit the scanned paths
    scannedPaths.push(...dependencyPaths);

    // Trust any of the dependency's decision if they say to ignore it
    const canTrust = dependencyPaths.some((path) => {
      const nsprcPath = `${path}.nsprc`;

      // Try retrieving the `.nsprc` file
      const nsprcFile: NsprcFile | boolean = readFile(nsprcPath);

      // File not found
      if (typeof nsprcFile === 'boolean') {
        return false;
      }

      // Audit the found paths
      foundPaths.push(nsprcPath);

      // Process the file to get valid exceptions
      const { exceptionIds, report: fileReport } = processExceptions(nsprcFile, []);
      const exceptionRow = fileReport.find(([exceptionId]) => Number(exceptionId) === vulnerabilityId);

      // Append the relevant exception into the maintainer report
      if (exceptionRow) {
        // Include the used path
        report.push(exceptionRow.concat(nsprcPath));
      }

      // Check if the maintainer have explicitly exclude the vulnerability
      return exceptionIds.includes(vulnerabilityId);
    });

    // We want every affected module paths to be validated `true`;
    // so if trust is broken already (previous round returns `false`), we will continue to return `false` until the end
    if (!finalTrust) {
      return false;
    }

    return canTrust;
  }, true);

  return {
    scannedPaths,
    foundPaths,
    trust,
    report,
  };
}

/**
 * Analyze the JSON string buffer
 * @param  {String}   jsonBuffer          NPM Audit JSON string buffer
 * @param  {Array}    exceptionIds        User's exception IDs
 * @param  {Object}   options             Parsed command options
 * @return {Object}                       Processed vulnerabilities details
 */
export function processAuditJson(jsonBuffer = '', exceptionIds: number[], options: ParsedCommandOptions): ProcessedResult {
  if (!isJsonString(jsonBuffer)) {
    return {
      unhandledIds: [],
      vulnerabilityIds: [],
      report: [],
      maintainerReport: [],
      failed: true,
    };
  }

  // NPM v6 uses `advisories`
  // NPM v7 uses `vulnerabilities`
  // Refer to the `test/__mocks__` folder for some sample mockups
  const { advisories, vulnerabilities }: NpmAuditJson = JSON.parse(jsonBuffer);

  // NPM v6 handling
  if (advisories) {
    return Object.values(advisories).reduce(
      (acc: ProcessedResult, cur: v6Advisory) => {
        const shouldAudit: boolean = mapLevelToNumber(cur.severity) >= mapLevelToNumber(options.level);
        const isExcepted: boolean = exceptionIds.includes(Number(cur.id));

        // Record this vulnerability into the report, and highlight it using yellow color if it's new
        acc.report.push([
          color(cur.id, isExcepted ? '' : 'yellow'),
          color(cur.module_name, isExcepted ? '' : 'yellow'),
          color(cur.title, isExcepted ? '' : 'yellow'),
          color(
            trimArray(
              cur.findings.reduce((a, c) => [...a, ...c.paths] as [], []),
              MAX_PATHS_SIZE,
            ).join('\n'),
            isExcepted ? '' : 'yellow',
          ),
          color(cur.severity, isExcepted ? '' : 'yellow', getSeverityBgColor(cur.severity)),
          color(cur.url, isExcepted ? '' : 'yellow'),
          isExcepted ? 'y' : color('n', 'yellow'),
        ]);

        acc.vulnerabilityIds.push(Number(cur.id));

        // Found unhandled vulnerabilities
        if (shouldAudit && !isExcepted) {
          acc.unhandledIds.push(Number(cur.id));
        }

        return acc;
      },
      {
        unhandledIds: [],
        vulnerabilityIds: [],
        report: [],
        maintainerReport: [],
      },
    );
  }

  // NPM v7 handling
  if (vulnerabilities) {
    return Object.values(vulnerabilities).reduce(
      (acc: ProcessedResult, cur: v7Vulnerability | string) => {
        // Inside `via` array, its either the related module name or the vulnerability source object.
        get(cur, 'via', []).forEach((vul: v7VulnerabilityVia | string) => {
          // The vulnerability ID is labeled as `source`
          const id = get(vul, 'source', '');

          // Let's skip if ID is a string (module name), and only focus on the root vulnerabilities
          if (!id || typeof id === 'string' || typeof vul === 'string') {
            return;
          }

          const shouldAudit = mapLevelToNumber(vul.severity) >= mapLevelToNumber(options.level);

          let isExceptedByMaintainers = false;
          let scannedDependenciesPaths: string[] = [];
          let foundDependenciesPaths: string[] = [];

          // If scan internal modules flag is enabled,
          if (options.scanModules && typeof cur !== 'string') {
            // Check inner dependencies if we can except this vulnerability
            const { scannedPaths, foundPaths, trust, report } = checkTrustInDependencies(id, cur.nodes);

            isExceptedByMaintainers = trust;

            if (scannedPaths.length) {
              scannedDependenciesPaths = scannedPaths;
            }
            if (foundPaths.length) {
              foundDependenciesPaths = foundPaths;
            }
            if (report.length) {
              acc.maintainerReport.push(...report);
            }
          }

          const isExceptedByUs = exceptionIds.includes(id);
          const isExcepted = isExceptedByUs || isExceptedByMaintainers;

          // Construct `isExcepted` value to display in the report
          let isExceptedValue = color('n', 'yellow');
          if (isExceptedByMaintainers) {
            isExceptedValue = 'auto';
          } else if (isExceptedByUs) {
            isExceptedValue = 'y';
          }

          // Record this vulnerability into the report, and highlight it using yellow color if it's new
          const securityReportRow = [
            color(String(id), isExcepted ? '' : 'yellow'),
            color(vul.name, isExcepted ? '' : 'yellow'),
            color(vul.title, isExcepted ? '' : 'yellow'),
            color(trimArray(get(cur, 'nodes', []), MAX_PATHS_SIZE).join('\n'), isExcepted ? '' : 'yellow'),
            color(vul.severity, isExcepted ? '' : 'yellow', getSeverityBgColor(vul.severity)),
            color(vul.url, isExcepted ? '' : 'yellow'),
            isExceptedValue,
          ];
          // Add additional info in debug mode
          if (options.debug) {
            securityReportRow.push(
              scannedDependenciesPaths.join(', '),
              `${foundDependenciesPaths.length}/${scannedDependenciesPaths.length}`,
            );
          }
          acc.report.push(securityReportRow);

          acc.vulnerabilityIds.push(id);

          // Found unhandled vulnerabilities
          if (shouldAudit && !isExcepted) {
            acc.unhandledIds.push(id);
          }
        });

        return acc;
      },
      {
        unhandledIds: [],
        vulnerabilityIds: [],
        report: [],
        maintainerReport: [],
      },
    );
  }
  return {
    unhandledIds: [],
    vulnerabilityIds: [],
    report: [],
    maintainerReport: [],
    failed: true,
  };
}

/**
 * Process all exceptions and return a list of exception IDs
 * @param  {Object | Boolean} nsprc           File content from `.nsprc`
 * @param  {Array}            cmdExceptions   Exceptions passed in via command line
 * @return {Array}                            List of found vulnerabilities
 */
export function getExceptionsIds(nsprc?: NsprcFile | boolean, cmdExceptions: number[] = []): number[] {
  // If file does not exists
  if (!nsprc || typeof nsprc !== 'object') {
    // If there are exceptions passed in from command line
    if (cmdExceptions.length) {
      // Display simple info
      console.info(`Exception IDs: ${cmdExceptions.join(', ')}`);
      return cmdExceptions;
    }

    return [];
  }

  // Process the content of the file along with the command line exceptions
  const { exceptionIds, report } = processExceptions(nsprc, cmdExceptions);

  printExceptionReport(report);

  return exceptionIds;
}

/**
 * Filter the given list in the `.nsprc` file for valid exceptions
 * @param  {Object} nsprc           The nsprc file content, contains exception info
 * @param  {Array}  cmdExceptions   Exceptions passed in via command line
 * @return {Object}                 Processed vulnerabilities details
 */
export function processExceptions(nsprc: NsprcFile, cmdExceptions: number[] = []): ProcessedReport {
  return Object.entries(nsprc).reduce(
    (acc: ProcessedReport, [id, details]: [string, string | NsprcConfigs]) => {
      const numberId = Number(id);
      const isValidId = !isNaN(numberId);
      const isActive = Boolean(get(details, 'active', true)); // default to true
      const notes = typeof details === 'string' ? details : get(details, 'notes', '');
      const { valid, expired, years } = analyzeExpiry(get(details, 'expiry'));

      // Color the status accordingly
      let status = color('active', 'green');
      if (expired) {
        status = color('expired', 'red');
      } else if (!isValidId || !valid) {
        status = color('invalid', 'red');
      } else if (!isActive) {
        status = color('inactive', 'yellow');
      }

      // Color the date accordingly
      let expiryDate = get(details, 'expiry') ? new Date(get(details, 'expiry')).toUTCString() : '';
      // If it was expired for more than 5 years ago, warn by coloring the date in red
      if (years && years <= -5) {
        expiryDate = color(expiryDate, 'red');
      } else if (years && years <= -1) {
        expiryDate = color(expiryDate, 'yellow');
      }

      acc.report.push([id, status, expiryDate, notes]);

      if (isValidId && isActive && !expired) {
        acc.exceptionIds.push(numberId);
      }

      return acc;
    },
    {
      exceptionIds: cmdExceptions,
      report: cmdExceptions.map((id) => [String(id), color('active', 'green'), '', '']),
    },
  );
}
